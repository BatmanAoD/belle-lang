// TODO handling "trivia" is quite difficult with the current version of Pest.
// There are plans to improve the language:
// https://github.com/pest-parser/pest/issues/333
// Consider helping improve Pest or switching to Antlr.

// Non-newline whitespace is not meaningful (TODO: other Unicode whitespace?)
WHITESPACE = _{ " " | "\t" }
// Block style comments
COMMENT = _{ "/*" ~ (!"*/" ~ ANY)* ~ "*/" }
// Single-line comments
COMMENT_SINGLE = _{ TRIVIA? ~ "//" ~ (!NEWLINE ~ ANY) * ~ NEWLINE }
// XXX why does this need to be excplicit to make `COMMENT_SINGLE` accept
// trivia?
TRIVIA = _{ (WHITESPACE | COMMENT)+ }
// Using newlines to terminate/separate items
EOL = _{ (COMMENT_SINGLE | NEWLINE)+ }

// Top-level elements: class, function
// Atomic because elements must start on column 0
// TODO: `pub`
Program = ${ SOI ~ ((Class | Function) ~ EOL* )+ ~ EOI } // XXX $

// general identifiers are like those in most languages, except `_` is only
// permitted as a 'separator' character
Ident = @{ ASCII_ALPHA ~ ( ASCII_ALPHANUMERIC | "_"  ~ &ASCII_ALPHANUMERIC )* }

// TODO make indentation more flexible
// Indentation = !{ "  " }

TypedVar = !{ Ident ~ ":" ~ TypeName }
PossiblyInferred = !{ TypedVar | Ident }
ParametersList = !{ "(" ~ (PossiblyInferred  ~ ("," ~ PossiblyInferred)* ~ ",")? ~ ")" }

// TODO: generics
Class = ${ ClassDecl ~ ClassBody }   // XXX $
ClassBody = !{ "{" ~ ( "}" | EOL ~ ClassItem* ~ "}" ) }
// The space between the `#` and the class name is mandatory
ClassDecl = ${ "# " ~ ClassName ~ (WHITESPACE+ | EOL) } // XXX $
// Class names must start with an uppercase letter and cannot contain
// underscores (TODO: permit underscores?)
ClassName = @{ ASCII_ALPHA_UPPER ~ ASCII_ALPHANUMERIC* }
// TODO: Why is trivia not permitted by `ClassItem`?
ClassItem = !{ ClassData | ClassRequests } // TODO permit declaring methods in body? | ClassMethods | ClassAux }

ClassData = !{ DataDecl ~ (DataMember ~ EOL)+ }
// TODO: optional indentation?
DataDecl = { WHITESPACE* ~ "## data" ~ EOL }   // XXX should be atomic, w/ indentation
DataMember = !{ TypedVar }

ClassRequests = !{ RequestDecl ~ (Request ~ EOL)+ }
RequestDecl = { WHITESPACE* ~ "## requests" ~ EOL }   // XXX should be atomic
Request = !{ WHITESPACE* ~ Ident ~ ParametersList? ~ ("->" ~ TypeName)? ~ CodeBlock? }

// TODO: generics, handlers
TypeName = !{ Qualified? ~ (Array | ClassName | Builtin) }
// `~` implies `mut`
Qualified = !{ UNIQUE | MUT }
UNIQUE = !{ "~" }
MUT = !{ "mut" }
Array = !{ Slice | SizedArray }
Slice = !{ "[" ~ TypeName ~ "]" }
SizedArray = !{ "[" ~ TypeName ~ "#" ~ NaturalNumber ~ "]" }
// TODO: more
Builtin = @{ "isize" | "usize" | "i8" | "u8" | "i16" | "u16" | "i32" | "u32" | "i64" |"u64" | "f32" | "f64" | "char32" | "String" }

NaturalNumber = @{ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* }

// As in Go, methods are functions with a receiver declared before the function name
Function = !{ "fn" ~ Receiver? ~ Ident ~ ParametersList? ~ ("->" ~ TypeName)? ~ CodeBlock }
Receiver = !{ "(" ~ QualifiedSelf ~ ")" }
// Unlike Go, the receiver is always named `self`. Unlike Rust, the type of the
// receiver is declared (since methods are not declared in an `impl` block),
// but the word `self` is not.
// TODO should it be possible to declare methods for arrays and/or builtins?
QualifiedSelf = !{ Qualified? ~ ClassName }

CodeBlock = !{ EOL? ~ "{" ~ EOL? ~ "XXX TODO" ~ "}" }

// Loops: `for` (as foreach) and `while` (no C-style `for`)
// Conditionals: `if` and `match`
